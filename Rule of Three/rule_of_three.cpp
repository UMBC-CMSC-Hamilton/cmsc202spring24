#include <iostream>
#include <vector>
using namespace std;


class Fraction
{
    public:
        Fraction() : num(0), denom(1) {}
        Fraction(int x, int y) : num(x), denom(y) {}
        /* what gets autogenerated 
        Fraction(const Fraction & other)
        {
            num = other.num;
            denom = other.denom;
        }
        
        Fraction & operator = (const Fraction & other)
        {
            num = other.num;
            denom = other.denom;
            return *this;
        }
        
        */



        int GetNumerator() {return num;}
        int GetDenominator() {return denom;}
        
        void SetNumerator(int new_num) {num = new_num;}
        void SetDenominator(int new_denom) {denom = new_denom;}
        
        Fraction & operator = (const Fraction & other)
        {
            if (&other != this)  // (other != *this) i've seen it but the pointer one is better
            {
                // prevents self assignments
            }
            return *this;
        }
        ~Fraction()
        {
            cout << "Destroying: " << num << " / " << denom << endl;
        }
    private:
        int num, denom;
};

/*
    When are destructors called?
        Just have a regular class that leaves scope
        When you call delete on a dynamic memory object
        For classes created in main, the destructor is called "when you return 0";
    When are they not called?
        if you use the new keyword and a class leaves scope
*/

void bad_function()
{
    Fraction regular(5, 3); // will call at the end 
    Fraction * pf = new Fraction(7, 4); // won't.  must call delete
    Fraction * array = new Fraction[7];

    for(int i = 0 ; i < 7; i++)
    {
        array[i].SetNumerator(i);
        array[i].SetDenominator(2 * i + 1);
    }
    delete [] array;
    cout << "ending the bad function" << endl;
    // this is where all of the non-pointers are destroyed
    // if you put another line of code here, then it's after that
}
/*
delete_linked_list(node * current)
{
    delete_linked_list(current->next);
    delete current;
}*/


int main()
{
    Fraction f1(2, 4);
    // use the assignment operator
    Fraction f2 = f1;
    // use the copy constructor
    Fraction f3(f1);
    (f1 = f3).SetDenominator(17);
    // we didn't write them but it'll work

    f1 = f1; // not usually 
    Fraction * p1 = &f1, *p2 = &f1;
    *p1 = *p2; // possible in some theoretical worlds
    cout << f1.GetNumerator() << " " << f1.GetDenominator() << endl;
    
    cout << f2.GetNumerator() << " " << f2.GetDenominator() << endl;
    cout << f3.GetNumerator() << " " << f3.GetDenominator() << endl;
    bad_function();
    return 0;
}